# Cursor AI Rules for Smart Brokerage App

## Project Context
This is a FSBO (For Sale By Owner) real estate platform for Ontario sellers with a focus on messaging between sellers and buyer agents.

## Tech Stack
- Backend: NestJS + Prisma + Supabase + Mailgun + BullMQ
- Mobile: Expo (React Native) + React Query + React Native Paper
- Shared: TypeScript types
- Monorepo: npm workspaces

## Code Style

### TypeScript
- Use strict TypeScript
- Prefer interfaces over types for object shapes
- Use enums for status/category fields
- Always import types from @smart-brokerage/shared

### NestJS Backend
- Use modular structure (one module per feature)
- Use dependency injection
- Controllers handle HTTP, Services handle business logic
- Use Prisma for all database operations
- Stub external services until configured (Mailgun, Supabase, Redis)

### React Native / Expo
- Use functional components with hooks
- Use React Query for server state
- Use React Native Paper for UI components
- Keep business logic in services/api.ts
- Use TypeScript for all components

### File Organization
- Group by feature (modules/listings/, modules/threads/, etc.)
- Keep types in packages/shared/src/types/
- One component per file
- Co-locate tests with source files

## Naming Conventions
- Components: PascalCase (ListingsScreen.tsx)
- Services: camelCase (listingsService)
- Files: kebab-case or PascalCase
- Database tables: snake_case (snake_case in Prisma schema)
- API endpoints: kebab-case (/listings/:id/threads)

## Important Patterns

### API Responses
Always return consistent shapes:
```typescript
{ success: boolean, data?: T, error?: string }
```

### Error Handling
- Use NestJS built-in exceptions
- Log errors with context
- Return user-friendly error messages

### Database Queries
- Use Prisma Client (already injected via PrismaService)
- Always handle null cases
- Use transactions for multi-step operations

### Mobile API Calls
- Use React Query for all API calls
- Handle loading, error, and success states
- Cache aggressively for read operations

## Email Threading & Message-IDs

### Critical Rules for Email Threading

**Message-ID Format (RFC 5322 Compliant)**
- Always generate RFC 5322 compliant Message-IDs: `<unique-id@resolvable-domain.com>`
- Use a RESOLVABLE domain (e.g., your Mailgun domain), NOT fake domains like `yourapp.ca`
- Format: `<${timestamp}.${listingAlias}@${mailgunDomain}>`
- Gmail and other providers will OVERRIDE invalid Message-IDs with their own (e.g., `SMTPIN_ADDED_BROKEN@mx.google.com`)
- If Message-IDs are invalid, email threading will break completely

**Database Message-ID Tracking**
- Store the `messageId` field on EVERY message (both inbound and outbound)
- Add index on `messageId` field for fast lookups
- For inbound: Extract from Mailgun webhook payload `eventData['Message-Id']`
- For outbound: Generate before sending, store in DB, pass to Mailgun with `h:Message-Id` header

**Thread Matching Strategy**
1. Extract ALL Message-IDs from incoming email:
   - Parse `References` header (full conversation chain)
   - Include `In-Reply-To` header (direct parent)
2. Search for ANY existing message with matching Message-ID
3. Filter by `listingId` + `senderId` to prevent cross-thread contamination
4. If match found, add to existing thread; otherwise create new thread

**Email Headers for Threading**
When sending outbound emails, always include:
- `h:Message-Id`: Our generated Message-ID (so Gmail doesn't override it)
- `h:In-Reply-To`: The root `thread.emailThreadId` (original buyer's Message-ID)
- `h:References`: Full chain of all Message-IDs in the thread (space-separated)

**References Chain Building**
```typescript
// Get all messages in thread
const threadMessages = await prisma.message.findMany({
  where: { threadId },
  select: { messageId: true },
  orderBy: { createdAt: 'asc' },
});

const referencesChain = threadMessages
  .map(m => m.messageId)
  .filter(Boolean)
  .join(' ');
```

**Common Pitfalls**
- ❌ Using unresolvable domains → Gmail overrides Message-ID
- ❌ Not storing Message-IDs in DB → Can't match replies
- ❌ Wrong parameter order in sendEmail() → Headers missing/incorrect
- ❌ Only storing one emailThreadId on thread → Fails after 2-3 replies
- ❌ Not parsing References header → Can't match later replies

**Debugging Email Threading Issues**
If replies create new threads instead of continuing conversation:
1. Check if outbound messages have `messageId` stored in DB
2. Check if Mailgun actually used your Message-ID (not Gmail's override)
3. Log all Message-IDs from incoming email's References/In-Reply-To
4. Verify domain in Message-ID is resolvable via DNS
5. Check parameter order matches: `sendEmail(from, to, subject, text, html, inReplyTo, references, messageId)`

## Stubbed Services
Until external services are configured, keep stub implementations:
- PrismaService: Log DB operations, return mock data
- SupabaseService: Log storage operations, return fake URLs
- MailgunService: Log email sends, don't actually send

## Database Seeding

### Sample Listings
The database seed creates two listings with fixed email aliases for testing:
- **Listing 1**: `l-abc123@inbox.yourapp.ca` (123 Main Street, Toronto)
- **Listing 2**: `l-xyz789@inbox.yourapp.ca` (456 Oak Avenue, Ottawa)

### Running Seeds
```bash
npm run prisma:seed
```

Seeds are located in `packages/api/prisma/seed.ts` and include:
- Two listings with unique email aliases
- Sample buyer agent senders
- Clear existing data before seeding (optional)

### Email Alias Routing
- Listing aliases (e.g., `l-abc123`) are used in email addresses
- When processing incoming emails, ALWAYS:
  1. Extract alias from recipient email
  2. Look up listing by `emailAlias` field
  3. Use the listing's UUID (NOT the alias) for thread/message creation
- Never use the alias directly as a listing ID

## When Adding Features
1. Update Prisma schema if needed
2. Run `npm run prisma:generate` and restart TypeScript server
3. Add types to packages/shared/src/types/
4. Create/update NestJS module
5. Add API client method in mobile/src/services/api.ts
6. Create React Query hooks in mobile screens
7. Update README with new endpoints
8. Update seed script if new required data

## Common Tasks

### Adding a new API endpoint:
1. Add to appropriate controller
2. Implement in service
3. Add to mobile/src/services/api.ts
4. Use with React Query in screen

### Adding a new database model:
1. Update prisma/schema.prisma
2. Run `npm run prisma:generate`
3. Add types to packages/shared/
4. Create service methods

### Adding a new screen:
1. Create in packages/mobile/src/screens/
2. Add to navigation/AppNavigator.tsx
3. Add API calls via React Query
4. Style with React Native Paper

## Troubleshooting

### Prisma TypeScript Errors After Schema Changes

**Problem:** After running `npm run prisma:generate` or `npm run prisma:migrate`, TypeScript shows errors like:
- `Module '"@prisma/client"' has no exported member 'PrismaClient'`
- `Property 'sender' does not exist on type 'PrismaService'`

**Solution:** TypeScript's cache needs to be refreshed:
1. **Primary fix:** Restart TypeScript Server
   - Press `Cmd + Shift + P` (Mac) or `Ctrl + Shift + P` (Windows/Linux)
   - Type: `TypeScript: Restart TS Server`
   - Press Enter
   
2. **If that doesn't work:** Reload VS Code Window
   - Press `Cmd + Shift + P` / `Ctrl + Shift + P`
   - Type: `Developer: Reload Window`
   - Press Enter

3. **Last resort:** Regenerate Prisma Client in the API package
   ```bash
   cd packages/api
   npx prisma generate
   ```
   Then restart TypeScript server (step 1)

**Why this happens:** Prisma generates TypeScript types dynamically. VS Code's TypeScript server caches the old types and needs to be restarted to pick up the new generated types.

### Expo Font Loading Errors

**Problem:** Errors with `@expo/vector-icons` or font loading (e.g., `Ionicons` not rendering)

**Solution:** Don't explicitly load icon fonts - they load automatically:
```typescript
// ❌ Don't do this
const [fontsLoaded] = useFonts({
  ...Ionicons.font,
});

// ✅ Do this instead
const [fontsLoaded] = useFonts({
  // Only add custom fonts here, not icon fonts
});
```

Icon fonts from `@expo/vector-icons` are loaded automatically by the library.

## Testing Strategy
- Unit tests for services (business logic)
- Integration tests for API endpoints
- E2E tests for critical user flows (later)

## Don't
- Don't connect real services until user registers
- Don't commit .env files
- Don't use `any` type
- Don't put business logic in controllers
- Don't make API calls outside services/api.ts

## Documentation
- Document complex business logic
- Add JSDoc comments for public APIs
- Update README when adding major features
- Keep TODO comments for stubbed services

