// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // For migrations, use: DATABASE_URL="<direct-url>?sslmode=require" npx prisma migrate deploy
  // For runtime, use pooler connection (set in .env)
}

// Seed configuration
// Run: npm run prisma:seed

// ============================================================
// LISTINGS
// ============================================================

model Listing {
  id          String        @id @default(uuid())
  address     String
  city        String
  province    String
  postalCode  String
  price       Float
  emailAlias  String        @unique // e.g., "l-abc123"
  sellerId    String
  status      ListingStatus @default(ACTIVE)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  threads Thread[]

  @@index([sellerId])
  @@index([emailAlias])
  @@index([status])
  @@map("listings")
}

enum ListingStatus {
  ACTIVE
  SOLD
  EXPIRED
  DRAFT
}

// ============================================================
// MESSAGE THREADS
// ============================================================

model Thread {
  id            String          @id @default(uuid())
  listingId     String
  senderId      String // FK to Sender
  subject       String
  emailThreadId String? // For grouping email replies (In-Reply-To header)
  category      MessageCategory @default(GENERAL)
  status        ThreadStatus    @default(ACTIVE)
  activeOfferId String? // Quick lookup for active offer in this thread
  lastMessageAt DateTime        @default(now())
  unreadCount   Int             @default(0)
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  listing  Listing   @relation(fields: [listingId], references: [id], onDelete: Cascade)
  sender   Sender    @relation(fields: [senderId], references: [id])
  messages Message[]
  offers   Offer[]

  @@index([listingId])
  @@index([senderId])
  @@index([lastMessageAt])
  @@index([emailThreadId])
  @@index([activeOfferId])
  @@map("threads")
}

enum ThreadStatus {
  ACTIVE
  ARCHIVED
}

enum MessageCategory {
  OFFER
  SHOWING
  GENERAL
}

enum MessageSubCategory {
  NEW_OFFER
  UPDATED_OFFER
  VIEWING_REQUEST
  AMENDMENT
  GENERAL
}

// ============================================================
// MESSAGES
// ============================================================

model Message {
  id                        String              @id @default(uuid())
  threadId                  String
  senderId                  String? // null if from seller (outbound)
  senderEmail               String
  senderName                String
  direction                 MessageDirection
  subject                   String
  bodyText                  String              @db.Text
  bodyHtml                  String?             @db.Text
  messageId                 String?
  status                    MessageStatus       @default(PENDING)
  rawEmailS3Key             String? // S3 key for raw .eml file
  subCategory               MessageSubCategory? // Classified intent
  classificationConfidence  Float? // 0-100 confidence score
  classificationReasoning   String?             @db.Text // Why it was classified this way
  offerId                   String? // Link to offer if this message contains/relates to an offer
  createdAt                 DateTime            @default(now())

  thread      Thread       @relation(fields: [threadId], references: [id], onDelete: Cascade)
  sender      Sender?      @relation(fields: [senderId], references: [id])
  attachments Attachment[]
  offer       Offer?       @relation(fields: [offerId], references: [id])

  @@index([threadId])
  @@index([senderId])
  @@index([createdAt])
  @@index([status])
  @@index([subCategory])
  @@index([offerId])
  @@map("messages")
}

enum MessageDirection {
  INBOUND  // From buyer agent to seller
  OUTBOUND // From seller to buyer agent
}

enum MessageStatus {
  PENDING  // Message created but not yet sent
  SENT     // Successfully sent via email
  FAILED   // Failed to send via email
  DELIVERED // Confirmed delivery (future: webhook from Mailgun)
}

// ============================================================
// ATTACHMENTS
// ============================================================

model Attachment {
  id                 String            @id @default(uuid())
  messageId          String
  filename           String
  contentType        String
  s3Key              String // Supabase Storage key
  size               Int
  virusScanStatus    VirusScanStatus   @default(PENDING)
  virusScanResult    String?
  documentAnalysisId String? // Link to analysis if this is an analyzed document
  createdAt          DateTime          @default(now())

  message          Message            @relation(fields: [messageId], references: [id], onDelete: Cascade)
  documentAnalysis DocumentAnalysis? @relation(fields: [documentAnalysisId], references: [id])

  @@index([messageId])
  @@index([documentAnalysisId])
  @@map("attachments")
}

enum VirusScanStatus {
  PENDING
  CLEAN
  INFECTED
  FAILED
}

// ============================================================
// SENDERS (Buyer Agents)
// ============================================================

model Sender {
  id                   String   @id @default(uuid())
  email                String   @unique
  name                 String
  domain               String // e.g., "remax.com"
  isVerified           Boolean  @default(false)
  verifiedAt           DateTime?
  verificationSource   String? // e.g., "CREA directory", "manual", "domain whitelist"
  brokerage            String?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  threads  Thread[]
  messages Message[]

  @@index([email])
  @@index([domain])
  @@index([isVerified])
  @@map("senders")
}

// ============================================================
// DOCUMENT ANALYSIS
// ============================================================

model DocumentAnalysis {
  id                String   @id @default(uuid())
  attachmentId      String // Which attachment was analyzed
  formType          String? // e.g., "Form 100 APS", "Form 120 Amendment"
  oreaFormDetected  Boolean  @default(false)
  relevanceScore    Float // 0-100, how relevant/important is this document
  confidence        Float // 0-100, confidence in the analysis
  extractedData     Json? // Structured data: {price, deposit, conditions, dates, etc}
  textContent       String?  @db.Text // Extracted text from PDF
  pageCount         Int?
  createdAt         DateTime @default(now())
  
  // Validation fields (for OREA form validation)
  validationStatus         String?  // 'passed', 'failed', 'not_validated'
  validationErrors         Json?    // Array of validation issues
  hasRequiredSignatures    Boolean? // Buyer signatures detected
  priceMatchesExtracted    Boolean? // Price field filled correctly
  formFieldsExtracted      Json?    // Raw APS parser result (ApsParseResult)

  attachments Attachment[]

  @@index([attachmentId])
  @@index([oreaFormDetected])
  @@index([relevanceScore])
  @@map("document_analyses")
}

// ============================================================
// OFFERS
// ============================================================

enum OfferStatus {
  PENDING_REVIEW // Seller hasn't reviewed yet
  AWAITING_SELLER_SIGNATURE // Seller accepted, waiting for signature
  AWAITING_BUYER_SIGNATURE // Counter-offer sent, waiting for buyer signature
  CONDITIONALLY_ACCEPTED // Seller signed, conditions pending fulfillment
  ACCEPTED // Fully signed and accepted (all conditions fulfilled)
  DECLINED // Seller declined
  COUNTERED // Seller sent counter-offer
  EXPIRED // Offer expired
  SUPERSEDED // Replaced by a newer offer from the same buyer
}

model Offer {
  id                          String      @id @default(uuid())
  threadId                    String
  messageId                   String // The message that contained this offer
  status                      OfferStatus @default(PENDING_REVIEW)
  
  // Offer Details (extracted from documents)
  price                       Float?
  deposit                     Float?
  closingDate                 DateTime?
  conditions                  String?     @db.Text
  expiryDate                  DateTime?
  
  // Lifecycle timestamps
  conditionallyAcceptedAt     DateTime? // When seller signed with conditions
  acceptedAt                  DateTime? // When all conditions fulfilled
  
  // Document references
  originalDocumentS3Key       String? // Original unsigned offer from buyer agent
  signedDocumentS3Key         String? // Signed document after acceptance
  counterOfferDocumentS3Key   String? // Counter-offer document if sent
  preparedDocumentS3Key       String? // Processed PDF with seller intake data prefilled
  
  // OREA form processing
  oreaVersion                 String? // Detected OREA version (e.g., "APS-2024")
  
  // Seller guided intake
  intakeData                  Json? // Seller's responses to guided intake form
  sellerEmail                 String?
  sellerName                  String?
  
  // Dropbox Sign tracking
  hellosignSignatureRequestId String? // Dropbox Sign signature request ID
  hellosignSignatureId        String? // Dropbox Sign signature_id (for embedded signing)
  signUrl                     String? // Embedded signing URL
  signatureViewedAt           DateTime? // When seller opened the signing UI
  sellerSignedAt              DateTime?
  buyerSignedAt               DateTime?
  
  // Counter-offer tracking
  isCounterOffer              Boolean     @default(false) // Identifies outgoing counter-offers
  originalOfferId             String? // Links to buyer's original offer
  
  // Metadata
  declineReason               String?     @db.Text
  errorMessage                String?     @db.Text // Error during preparation or signing
  createdAt                   DateTime    @default(now())
  updatedAt                   DateTime    @updatedAt

  thread           Thread            @relation(fields: [threadId], references: [id], onDelete: Cascade)
  messages         Message[]
  offerConditions  OfferCondition[]
  originalOffer    Offer?            @relation("CounterOffers", fields: [originalOfferId], references: [id])
  counterOffers    Offer[]           @relation("CounterOffers")

  @@index([threadId])
  @@index([messageId])
  @@index([status])
  @@index([expiryDate])
  @@index([originalOfferId])
  @@map("offers")
}

// ============================================================
// OFFER CONDITIONS
// ============================================================

enum OfferConditionStatus {
  PENDING   // Created from APS, not yet fulfilled
  COMPLETED // Marked fulfilled via OREA 124 or manually
  EXPIRED   // Not completed by due date
  WAIVED    // Condition waived (future: OREA waiver forms)
}

model OfferCondition {
  id            String                @id @default(cuid())
  offerId       String
  description   String                @db.Text // Free-text condition description
  dueDate       DateTime?             // Optional due date for this condition
  status        OfferConditionStatus  @default(PENDING)
  completedAt   DateTime?             // When condition was marked completed
  matchingKey   String?               // Normalized text for matching with OREA 124
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt

  offer Offer @relation(fields: [offerId], references: [id], onDelete: Cascade)

  @@index([offerId])
  @@index([status])
  @@index([dueDate])
  @@map("offer_conditions")
}

// ============================================================
// AGREEMENTS - REMOVED (consolidated into Offer model)
// ============================================================
// The Offer model now handles the complete workflow:
// - Buyer's offer terms (from document analysis)
// - Seller's guided intake data
// - PDF preparation and signing
// - Signature tracking

