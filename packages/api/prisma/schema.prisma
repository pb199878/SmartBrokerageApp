// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("POOLER_DATABASE_URL")
}

// Seed configuration
// Run: npm run prisma:seed

// ============================================================
// LISTINGS
// ============================================================

model Listing {
  id          String        @id @default(uuid())
  address     String
  city        String
  province    String
  postalCode  String
  price       Float
  emailAlias  String        @unique // e.g., "l-abc123"
  sellerId    String
  status      ListingStatus @default(ACTIVE)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  threads Thread[]

  @@index([sellerId])
  @@index([emailAlias])
  @@index([status])
  @@map("listings")
}

enum ListingStatus {
  ACTIVE
  SOLD
  EXPIRED
  DRAFT
}

// ============================================================
// MESSAGE THREADS
// ============================================================

model Thread {
  id            String          @id @default(uuid())
  listingId     String
  senderId      String // FK to Sender
  subject       String
  emailThreadId String? // For grouping email replies (In-Reply-To header)
  category      MessageCategory @default(GENERAL)
  status        ThreadStatus    @default(ACTIVE)
  activeOfferId String? // Quick lookup for active offer in this thread
  lastMessageAt DateTime        @default(now())
  unreadCount   Int             @default(0)
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  listing  Listing   @relation(fields: [listingId], references: [id], onDelete: Cascade)
  sender   Sender    @relation(fields: [senderId], references: [id])
  messages Message[]
  offers   Offer[]

  @@index([listingId])
  @@index([senderId])
  @@index([lastMessageAt])
  @@index([emailThreadId])
  @@index([activeOfferId])
  @@map("threads")
}

enum ThreadStatus {
  ACTIVE
  ARCHIVED
}

enum MessageCategory {
  OFFER
  SHOWING
  GENERAL
}

enum MessageSubCategory {
  NEW_OFFER
  UPDATED_OFFER
  VIEWING_REQUEST
  AMENDMENT
  GENERAL
}

// ============================================================
// MESSAGES
// ============================================================

model Message {
  id                        String              @id @default(uuid())
  threadId                  String
  senderId                  String? // null if from seller (outbound)
  senderEmail               String
  senderName                String
  direction                 MessageDirection
  subject                   String
  bodyText                  String              @db.Text
  bodyHtml                  String?             @db.Text
  messageId                 String?
  status                    MessageStatus       @default(PENDING)
  rawEmailS3Key             String? // S3 key for raw .eml file
  subCategory               MessageSubCategory? // Classified intent
  classificationConfidence  Float? // 0-100 confidence score
  classificationReasoning   String?             @db.Text // Why it was classified this way
  offerId                   String? // Link to offer if this message contains/relates to an offer
  createdAt                 DateTime            @default(now())

  thread      Thread       @relation(fields: [threadId], references: [id], onDelete: Cascade)
  sender      Sender?      @relation(fields: [senderId], references: [id])
  attachments Attachment[]
  offer       Offer?       @relation(fields: [offerId], references: [id])

  @@index([threadId])
  @@index([senderId])
  @@index([createdAt])
  @@index([status])
  @@index([subCategory])
  @@index([offerId])
  @@map("messages")
}

enum MessageDirection {
  INBOUND  // From buyer agent to seller
  OUTBOUND // From seller to buyer agent
}

enum MessageStatus {
  PENDING  // Message created but not yet sent
  SENT     // Successfully sent via email
  FAILED   // Failed to send via email
  DELIVERED // Confirmed delivery (future: webhook from Mailgun)
}

// ============================================================
// ATTACHMENTS
// ============================================================

model Attachment {
  id                 String            @id @default(uuid())
  messageId          String
  filename           String
  contentType        String
  s3Key              String // Supabase Storage key
  size               Int
  virusScanStatus    VirusScanStatus   @default(PENDING)
  virusScanResult    String?
  documentAnalysisId String? // Link to analysis if this is an analyzed document
  createdAt          DateTime          @default(now())

  message          Message            @relation(fields: [messageId], references: [id], onDelete: Cascade)
  documentAnalysis DocumentAnalysis? @relation(fields: [documentAnalysisId], references: [id])

  @@index([messageId])
  @@index([documentAnalysisId])
  @@map("attachments")
}

enum VirusScanStatus {
  PENDING
  CLEAN
  INFECTED
  FAILED
}

// ============================================================
// SENDERS (Buyer Agents)
// ============================================================

model Sender {
  id                   String   @id @default(uuid())
  email                String   @unique
  name                 String
  domain               String // e.g., "remax.com"
  isVerified           Boolean  @default(false)
  verifiedAt           DateTime?
  verificationSource   String? // e.g., "CREA directory", "manual", "domain whitelist"
  brokerage            String?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  threads  Thread[]
  messages Message[]

  @@index([email])
  @@index([domain])
  @@index([isVerified])
  @@map("senders")
}

// ============================================================
// DOCUMENT ANALYSIS
// ============================================================

model DocumentAnalysis {
  id                String   @id @default(uuid())
  attachmentId      String // Which attachment was analyzed
  formType          String? // e.g., "Form 100 APS", "Form 120 Amendment"
  oreaFormDetected  Boolean  @default(false)
  relevanceScore    Float // 0-100, how relevant/important is this document
  confidence        Float // 0-100, confidence in the analysis
  extractedData     Json? // Structured data: {price, deposit, conditions, dates, etc}
  textContent       String?  @db.Text // Extracted text from PDF
  pageCount         Int?
  createdAt         DateTime @default(now())
  
  // Validation fields (for OREA form validation)
  validationStatus       String?  // 'passed', 'failed', 'not_validated'
  validationErrors       Json?    // Array of validation issues
  hasRequiredSignatures  Boolean? // Buyer signatures detected
  priceMatchesExtracted  Boolean? // Price field filled correctly
  docupipeJobId          String?  // DocuPipe job ID for reference
  formFieldsExtracted    Json?    // Raw DocuPipe form fields (full response)

  attachments Attachment[]

  @@index([attachmentId])
  @@index([oreaFormDetected])
  @@index([relevanceScore])
  @@map("document_analyses")
}

// ============================================================
// OFFERS
// ============================================================

enum OfferStatus {
  PENDING_REVIEW // Seller hasn't reviewed yet
  AWAITING_SELLER_SIGNATURE // Seller accepted, waiting for signature
  AWAITING_BUYER_SIGNATURE // Counter-offer sent, waiting for buyer signature
  ACCEPTED // Fully signed and accepted
  DECLINED // Seller declined
  COUNTERED // Seller sent counter-offer
  EXPIRED // Offer expired
  SUPERSEDED // Replaced by a newer offer from the same buyer
}

model Offer {
  id                          String      @id @default(uuid())
  threadId                    String
  messageId                   String // The message that contained this offer
  status                      OfferStatus @default(PENDING_REVIEW)
  
  // Offer Details (extracted from documents)
  price                       Float?
  deposit                     Float?
  closingDate                 DateTime?
  conditions                  String?     @db.Text
  expiryDate                  DateTime?
  
  // Document references
  originalDocumentS3Key       String? // Original unsigned offer from buyer agent
  signedDocumentS3Key         String? // Signed document after acceptance
  counterOfferDocumentS3Key   String? // Counter-offer document if sent
  
  // Dropbox Sign tracking
  hellosignSignatureRequestId String? // Dropbox Sign signature request ID
  sellerSignedAt              DateTime?
  buyerSignedAt               DateTime?
  
  // Metadata
  declineReason               String?     @db.Text
  createdAt                   DateTime    @default(now())
  updatedAt                   DateTime    @updatedAt

  thread   Thread    @relation(fields: [threadId], references: [id], onDelete: Cascade)
  messages Message[]

  @@index([threadId])
  @@index([messageId])
  @@index([status])
  @@index([expiryDate])
  @@map("offers")
}

// ============================================================
// AGREEMENTS (OREA APS)
// ============================================================

enum AgreementStatus {
  PENDING_SELLER_INTAKE // Waiting for seller to fill guided form
  PREPARING             // Server is preparing the PDF
  READY_TO_SIGN         // Dropbox Sign signature request created
  SIGNING_IN_PROGRESS   // Seller has opened the signing interface
  SIGNED                // Fully signed
  FAILED                // Error during preparation or signing
  CANCELLED             // Cancelled by seller
}

model Agreement {
  id                    String           @id @default(uuid())
  listingId             String
  threadId              String? // Optional link to thread if from email
  
  // Source document (buyer's APS)
  buyerApsAttachmentId  String? // Link to attachment if from email
  buyerApsFileKey       String? // Direct Supabase key if not from attachment
  oreaVersion           String? // e.g., "APS-2024", "APS-2023"
  
  // Prepared document
  preparedFileKey       String? // Supabase key for filled PDF
  
  // Seller info
  sellerEmail           String
  sellerName            String?
  
  // Intake data (JSON blob of seller responses)
  intakeData            Json?
  
  // Status tracking
  status                AgreementStatus  @default(PENDING_SELLER_INTAKE)
  errorMessage          String?          @db.Text
  
  // Timestamps
  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @updatedAt
  preparedAt            DateTime?
  signedAt              DateTime?

  signatureRequests SignatureRequest[]

  @@index([listingId])
  @@index([threadId])
  @@index([buyerApsAttachmentId])
  @@index([status])
  @@map("agreements")
}

// ============================================================
// SIGNATURE REQUESTS (Dropbox Sign tracking)
// ============================================================

enum SignatureProvider {
  DROPBOX_SIGN
}

enum SignatureRequestStatus {
  CREATED           // Request created, URL generated
  VIEWED            // Signer opened the document
  SIGNED            // Signer completed signing
  DECLINED          // Signer declined
  CANCELLED         // Cancelled by us or provider
  ERROR             // Error from provider
}

model SignatureRequest {
  id                    String                  @id @default(uuid())
  agreementId           String
  
  // Provider info
  provider              SignatureProvider       @default(DROPBOX_SIGN)
  providerRequestId     String // Dropbox Sign signature_request_id
  providerSignatureId   String? // Dropbox Sign signature_id (per signer)
  
  // Signer info
  signerEmail           String
  signerName            String?
  
  // Status
  status                SignatureRequestStatus  @default(CREATED)
  
  // URLs
  signUrl               String? // Embedded signing URL
  
  // Document
  finalDocumentFileKey  String? // Supabase key for final signed document
  
  // Timestamps
  createdAt             DateTime                @default(now())
  updatedAt             DateTime                @updatedAt
  viewedAt              DateTime?
  signedAt              DateTime?

  agreement Agreement @relation(fields: [agreementId], references: [id], onDelete: Cascade)

  @@index([agreementId])
  @@index([providerRequestId])
  @@index([status])
  @@map("signature_requests")
}

